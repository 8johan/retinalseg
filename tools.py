# -*- coding: utf-8 -*-
"""tools.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1kRVenFlpls9DaTmP1W8Dze_Ck8GhglDj
"""



import os
import numpy as np
import cv2
import torch
from torch.utils.data import Dataset
from glob import glob
from tqdm import tqdm
import imageio
from albumentations import HorizontalFlip, VerticalFlip, Rotate ,Blur,GaussNoise,OpticalDistortion,RandomSizedCrop
from albumentations.augmentations.transforms import Equalize , Normalize ,RandomGamma ,ISONoise

import time
import random

class imgDataset(Dataset):
    def __init__(self, images_path, masks_path ):

        self.images_path = images_path
        self.masks_path = masks_path
        self.n_samples = len(images_path)


    def __getitem__(self, index):
        """ Reading image """
        image = cv2.imread(self.images_path[index], cv2.IMREAD_COLOR)
        image = image/255.0 ## (512, 512, 3)
        image = np.transpose(image, (2, 0, 1))  ## (3, 512, 512)
        image = image.astype(np.float32)
        image = torch.from_numpy(image)

        """ Reading mask """
        mask = cv2.imread(self.masks_path[index], cv2.IMREAD_GRAYSCALE)
        mask = mask/255.0   ## (512, 512)
        mask = np.expand_dims(mask, axis=0) ## (1, 512, 512)
        mask = mask.astype(np.float32)
        mask = torch.from_numpy(mask)



        return image, mask


    def __len__(self):
        return self.n_samples



def create_dir(path):
    if not os.path.exists(path):
        os.makedirs(path)

def load_drivedata(path):
    train_x = sorted(glob(os.path.join(path, "training", "images", "*.tif")))
    train_y = sorted(glob(os.path.join(path, "training","1st_manual", "*.gif")))

    test_x = sorted(glob(os.path.join(path, "test", "images", "*.tif")))
    test_y = sorted(glob(os.path.join(path, "test", "1st_manual", "*.gif")))


    return (train_x, train_y), (test_x, test_y)
def load_chasdb1data(path):
    train_x = sorted(glob(os.path.join(path, "train", "image", "*.jpg")))
    train_y = sorted(glob(os.path.join(path, "train","mask","expert1", "*.png")))

    test_x = sorted(glob(os.path.join(path, "test", "image", "*.jpg")))
    test_y = sorted(glob(os.path.join(path, "test", "mask", "*.png")))


    return (train_x, train_y), (test_x, test_y)


def data_augment(images, masks, save_path, augment=True):
    size = (512, 512)

    for idx, (x, y) in tqdm(enumerate(zip(images, masks)), total=len(images)):
        """ Extracting the name """
        name = x.split("/")[-1].split(".")[0]

        """ Reading image and mask """
        x = cv2.imread(x, cv2.IMREAD_COLOR)
        y = imageio.mimread(y)[0]

        if augment == True:
            aug = HorizontalFlip(p=1.0)
            augmented = aug(image=x, mask=y)
            x1 = augmented["image"]
            y1 = augmented["mask"]

            aug = VerticalFlip(p=1.0)
            augmented = aug(image=x, mask=y)
            x2 = augmented["image"]
            y2 = augmented["mask"]

            aug = Rotate(limit=180, p=1.0)
            augmented = aug(image=x, mask=y)
            x3 = augmented["image"]
            y3 = augmented["mask"]

            aug = Blur(blur_limit=7,p=1.0)
            augmented = aug(image=x, mask=y)
            x4 = augmented["image"]
            y4 = augmented["mask"]

            aug = GaussNoise(mean=1.0,p=1.0)
            augmented = aug(image=x, mask=y)
            x5 = augmented["image"]
            y5 = augmented["mask"]

            aug=OpticalDistortion(distort_limit=5, shift_limit=0.5, p=1)
            augmented = aug(image=x, mask=y)
            x6 = augmented["image"]
            y6 = augmented["mask"]

            aug=RandomSizedCrop(min_max_height=(50, 200), height=512, width=512, p=0.5)
            augmented = aug(image=x, mask=y)
            x7 = augmented["image"]
            y7 = augmented["mask"]




            mode='pil'
            by_channels=True
            mask=None
            mask_params=()
            aug= Equalize(mode, by_channels, mask, mask_params, p=1.0)
            augmented = aug(image=x, mask=y)
            x8 = augmented["image"]
            y8 = augmented["mask"]

            aug=RandomGamma(gamma_limit=(8, 50), eps=None, always_apply=True, p=0.5)
            augmented = aug(image=x, mask=y)
            x9 = augmented["image"]
            y9 = augmented["mask"]





            X = [x, x1, x2, x3,x4,x5,x6,x7,x8,x9]
            Y = [y, y1, y2, y3,y4,y5,y6,y7,y8,y9]

        else:
            X = [x]
            Y = [y]

        index = 0
        for i, m in zip(X, Y):
            i = cv2.resize(i, size)
            m = cv2.resize(m, size)

            tmp_image_name = f"{name}_{index}.png"
            tmp_mask_name = f"{name}_{index}.png"

            image_path = os.path.join(save_path, "image", tmp_image_name)
            mask_path = os.path.join(save_path, "mask", tmp_mask_name)

            cv2.imwrite(image_path, i)
            cv2.imwrite(mask_path, m)

            index += 1
def augmentchasdb1_data(images, masks, save_path, augment=True):
    size = (512, 512)

    for idx, (x, y) in tqdm(enumerate(zip(images, masks)), total=len(images)):
        """ Extracting the name """
        name = x.split("/")[-1].split(".")[0]

        """ Reading image and mask """
        x = cv2.imread(x, cv2.IMREAD_COLOR)
        y = cv2.imread(y, cv2.IMREAD_GRAYSCALE)

        if augment == True:
            aug = HorizontalFlip(p=1.0)
            augmented = aug(image=x, mask=y)
            x1 = augmented["image"]
            y1 = augmented["mask"]

            aug = VerticalFlip(p=1.0)
            augmented = aug(image=x, mask=y)
            x2 = augmented["image"]
            y2 = augmented["mask"]

            aug = Rotate(limit=180, p=1.0)
            augmented = aug(image=x, mask=y)
            x3 = augmented["image"]
            y3 = augmented["mask"]

            aug = Blur(blur_limit=7,p=1.0)
            augmented = aug(image=x, mask=y)
            x4 = augmented["image"]
            y4 = augmented["mask"]

            aug = GaussNoise(mean=1.0,p=1.0)
            augmented = aug(image=x, mask=y)
            x5 = augmented["image"]
            y5 = augmented["mask"]

            aug=OpticalDistortion(distort_limit=5, shift_limit=0.5, p=1)
            augmented = aug(image=x, mask=y)
            x6 = augmented["image"]
            y6 = augmented["mask"]

            aug=RandomSizedCrop(min_max_height=(50, 200), height=512, width=512, p=0.5)
            augmented = aug(image=x, mask=y)
            x7 = augmented["image"]
            y7 = augmented["mask"]




            mode='pil'
            by_channels=True
            mask=None
            mask_params=()
            aug= Equalize(mode, by_channels, mask, mask_params, p=1.0)
            augmented = aug(image=x, mask=y)
            x8 = augmented["image"]
            y8 = augmented["mask"]

            aug=RandomGamma(gamma_limit=(8, 50), eps=None, always_apply=True, p=0.5)
            augmented = aug(image=x, mask=y)
            x9 = augmented["image"]
            y9 = augmented["mask"]





            X = [x, x1, x2, x3,x4,x5,x6,x7,x8,x9]
            Y = [y, y1, y2, y3,y4,y5,y6,y7,y8,y9]

        else:
            X = [x]
            Y = [y]

        index = 0
        for i, m in zip(X, Y):
            i = cv2.resize(i, size)
            m = cv2.resize(m, size)

            tmp_image_name = f"{name}_{index}.png"
            tmp_mask_name = f"{name}_{index}.png"

            image_path = os.path.join(save_path, "image", tmp_image_name)
            mask_path = os.path.join(save_path, "mask", tmp_mask_name)

            cv2.imwrite(image_path, i)
            cv2.imwrite(mask_path, m)

            index += 1



def seeding(seed):
    random.seed(seed)
    os.environ["PYTHONHASHSEED"] = str(seed)
    np.random.seed(seed)
    torch.manual_seed(seed)
    torch.cuda.manual_seed(seed)
    torch.backends.cudnn.deterministic = True

def epoch_time(start_time, end_time):
    elapsed_time = end_time - start_time
    elapsed_mins = int(elapsed_time / 60)
    elapsed_secs = int(elapsed_time - (elapsed_mins * 60))
    return elapsed_mins, elapsed_secs



from glob import glob
from torch.utils.data import DataLoader





def train(model, loader, optimizer, loss_fn, device):
    epoch_loss = 0.0

    model.train()
    for x, y in loader:



        x = x.to(device, dtype=torch.float32)
        y = y.to(device, dtype=torch.float32)

        optimizer.zero_grad()
        y_pred = model(x)
        loss = loss_fn(y_pred, y)
        loss.backward( )
        optimizer.step()
        epoch_loss += loss.item()

    epoch_loss = epoch_loss/len(loader)
    return epoch_loss

def evaluate(model, loader, loss_fn, device):
    epoch_loss = 0.0

    model.eval()
    with torch.no_grad():

        for x, y in loader:
            x = x.to(device, dtype=torch.float32)
            y = y.to(device, dtype=torch.float32)

            y_pred = model(x)
            loss = loss_fn(y_pred, y)
            epoch_loss += loss.item()

    epoch_loss = epoch_loss/len(loader)
    return epoch_loss



class DiceLoss(nn.Module):
    def __init__(self, weight=None, size_average=True):
        super(DiceLoss, self).__init__()
        self.sig=nn.Sigmoid()

    def forward(self, inputs, targets, smooth=1):

        #comment out if your model contains a sigmoid or equivalent activation layer
        inputs = self.sig(inputs)

        #flatten label and prediction tensors
        inputs = inputs.view(-1)
        targets = targets.view(-1)

        intersection = (inputs * targets).sum()
        dice = (2.*intersection + smooth)/(inputs.sum() + targets.sum() + smooth)

        return 1 - dice



import os, time
from operator import add

from tqdm import tqdm
import imageio

from sklearn.metrics import accuracy_score, f1_score, jaccard_score, precision_score, recall_score
def calculate_metrics(y_true, y_pred):
    """ Ground truth """
    y_true = y_true.cpu().numpy()
    y_true = y_true > 0.5
    y_true = y_true.astype(np.uint8)
    y_true = y_true.reshape(-1)

    """ Prediction """
    y_pred = y_pred.cpu().numpy()
    y_pred = y_pred > 0.5
    y_pred = y_pred.astype(np.uint8)
    y_pred = y_pred.reshape(-1)

    score_jaccard = jaccard_score(y_true, y_pred)
    score_f1 = f1_score(y_true, y_pred)
    score_recall = recall_score(y_true, y_pred)
    score_precision = precision_score(y_true, y_pred)
    score_acc = accuracy_score(y_true, y_pred)

    return [score_jaccard, score_f1, score_recall, score_precision, score_acc]

def mask_parse(mask):
    mask = np.expand_dims(mask, axis=-1)    ## (512, 512, 1)
    mask = np.concatenate([mask, mask, mask], axis=-1)  ## (512, 512, 3)
    return mask